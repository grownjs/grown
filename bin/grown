#!/bin/sh

':' // ; exec "$(command -v nodejs || command -v node)" "$0" "$@"
;

'use strict';

/* eslint-disable global-require */

const GROWN_TXT = `
  \u001b[32m▄████  ██▀███   ▒█████   █     █░███▄    █\u001b[39m
 \u001b[32m██▒ ▀█▒▓██ ▒ ██▒▒██▒  ██▒▓█░ █ ░█░██ ▀█   █\u001b[39m
\u001b[32m▒██░▄▄▄░▓██ ░▄█ ▒▒██░  ██▒▒█░ █ ░█▓██  ▀█ ██▒\u001b[39m
\u001b[32m░▓█  ██▓▒██▀▀█▄  ▒██   ██░░█░ █ ░█▓██▒  ▐▌██▒\u001b[39m
\u001b[32m░▒▓███▀▒░██▓ ▒██▒░ ████▓▒░░░██▒██▓▒██░   ▓██░\u001b[39m
 \u001b[32m░▒   ▒ ░ ▒▓ ░▒▓░░ ▒░▒░▒░ ░ ▓░▒ ▒ ░ ▒░   ▒ ▒\u001b[39m
  \u001b[32m░   ░   ░▒ ░ ▒░  ░ ▒ ▒░   ▒ ░ ░ ░ ░░   ░ ▒░\u001b[39m
  \u001b[32m░   ░   ░░   ░ ░ ░ ░ ▒    ░   ░    ░   ░ ░\u001b[39m
      \u001b[32m░    ░         ░ ░      ░            ░\u001b[39m
`;

const $ = require('wargs')(process.argv.slice(2), {
  booleans: 'ODIGRCAusVvdfqhly',
  camelCase: true,
  defaults: {
    cwd: process.cwd(),
    port: process.env.PORT || 8080,
    host: process.env.HOST || '0.0.0.0',
  },
  aliases: {
    y: 'interactive',
    O: 'no-install-opts',
    D: 'no-install-dev',
    I: 'no-install',
    G: 'no-clone',
    R: 'no-exec',
    C: 'no-copy',
    A: 'no-add',
    i: 'repl',
    u: 'uws',
    s: 'https',
    v: 'version',
    V: 'verbose',
    d: 'debug',
    f: 'force',
    q: 'quiet',
    x: 'exec',
    P: 'port',
    H: 'host',
    h: 'help',
    l: 'list',
    c: 'cwd',
    e: 'env',
  },
});

// defaults
process.name = 'grown';

process.env.NODE_ENV = $.flags.env || 'development';

/* istanbul ignore else */
if (process.env.CI) {
  process.env.NODE_ENV = 'ci';
}

delete $.flags.env;

const thisPkg = require('../package.json');
const exec = require('child_process').exec;
const cleanStack = require('clean-stack');
const chalk = require('chalk');
const path = require('path');
const fs = require('fs');

let _task = $._.shift();

const _ = require('./lib/util');

const _bin = path.basename(thisPkg.bin);

const aliases = {
  generate: ['g', 'add'],
  start: ['s', 'up'],
  repl: ['c'],
};

Object.keys(aliases).forEach(key => {
  /* istanbul ignore else */
  if (aliases[key].indexOf(_task) > -1) {
    _task = key;
  }
});

/* istanbul ignore else */
if (!_task && $.flags.list) {
  _task = 'generate';
}

const IS_DEBUG = $.flags.debug === true;

/* istanbul ignore else */
if (IS_DEBUG) {
  require('debug').enable('grown,grown:*');
}

const cwd = $.flags.cwd || process.cwd();

delete $.flags.cwd;

function showHelp() {
  _.echo(`${GROWN_TXT}
  Usage:
    ${_bin} new APP_PATH [...]

  Presets:
    ES6=buble|babel|traceur
    STYLES=less|sass|styl|postcss
    BUNDLER=fusebox|webpack|rollup
    RELOADER=browser-sync|live-reload
    DATABASE=postgres|mysql|mssql|sqlite

  Initialization options:
    -O, [--no-install-opts]   # Skip installing dependencies
    -D, [--no-install-dev]    # Skip installing dependencies
    -I, [--no-install]        # Skip installing dependencies
    -G, [--no-clone]          # Skip cloning repositories
    -R, [--no-exec]           # Skip running commands
    -C, [--no-copy]           # Skip copying sources
    -A, [--no-add]            # Skip writing files
    -f, [--force]             # Force without asking
    -V, [--verbose]           # Installation logs
    -y, [--interactive]       # Interactive mode

  Runtime options:
    -d, [--debug]             # Enable all debug messages
    -q, [--quiet]             # Suppress status output
    -c, [--cwd]               # Set the process.cwd()
    -P, [--port]              # Set PORT value (default: 80)
    -H, [--host]              # Set HOST value (default: 0.0.0.0)
    -e, [--env]               # Set NODE_ENV value (default: development)

  Server options:
    -i, [--repl]              # Enable the REPL
    -u, [--uws]               # Force UWS
    -s, [--https]             # Force HTTP

  Other actions:
    ${_bin} g|add|generate [...]
    ${_bin} s|up|start [...]
    ${_bin} c|repl

  Grown options:
    -l, [--list]         # List available generators
    -h, [--help]         # Show this help message and quit
    -x, [--exec]         # Execute a command before running
    -v, [--version]      # Show Grown version number and quit\n`);
}

function start(cb) {
  const _start = new Date();

  process.on('exit', () => _.echo('\r',
    chalk.green($.flags.force && !$.flags.interactive
      ? `✔ Done in ${(new Date() - _start) / 1000}s`
      : '✔ Done.'), '\r\n'));

  if ($.flags.exec) {
    const child = exec($.flags.exec);

    child.stdout.pipe(process.stdout);
    child.stderr.pipe(process.stderr);

    child.on(process.version.split('.')[1] === '6' ? 'exit' : 'close', exitCode => {
      if (exitCode !== 0) {
        _.die(1);
      } else {
        cb();
      }
    });
  } else {
    cb();
  }
}

function run() {
  try {
    _.echo(chalk.gray(`Grown v${thisPkg.version} (NODE_ENV=${process.env.NODE_ENV})`), '\r\n');

    const _tasks = {
      generate: require('./tasks/generate'),
      start: require('./tasks/start'),
      repl: require('./tasks/repl'),
      new: require('./tasks/new'),
    };

    switch (_task) {
      case 'generate':
      case 'start':
      case 'repl':
      case 'new':
        _tasks[_task]($, cwd);
        break;

      default: {
        const _file = path.join(cwd, `lib/tasks/${_task}`);

        let _call;

        try {
          // try user first, then built-in
          _call = require(!fs.existsSync(_file)
            ? `./tasks/scripts/${_task}`
            : _file);
        } catch (e) {
          throw new Error(`Task 'lib/tasks/${_task}' not implemented`);
        }

        /* istanbul ignore else */
        if (typeof _call !== 'function') {
          throw new Error(`Task must be a function, given: ${_call}`);
        }

        const _farm = require(path.join(cwd, 'app/server'));

        _farm().emit('start')
          .then(ctx => _call(ctx, $, {
            ok: msg => _.echo('\r', chalk.green(msg), '\n'),
            log: msg => _.echo('\r', chalk.gray(msg), '\n'),
            fail: msg => _.echo('\r', chalk.red(msg), '\n'),
            write: msg => _.echo(msg),
          }))
          .catch(e => {
            _.echo(chalk.red(($.flags.debug && cleanStack(e.stack)) || e.message), '\r\n');
            _.die(1);
          });
      }
    }
  } catch (e) {
    _.echo(chalk.red(($.flags.debug && cleanStack(e.stack)) || e.message), '\r\n');
    _.die(1);
  }
}

/* istanbul ignore else */
if ($.flags.version) {
  _.echo(chalk.green(`${thisPkg.name} v${thisPkg.version}`), '\r\n');
  _.die();
}

/* istanbul ignore else */
if ((!_task || $.flags.help) && !$.params.exec) {
  showHelp();
  _.die();
} else {
  start(_task ? run : _.die);
}
