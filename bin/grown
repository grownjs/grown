#!/bin/sh

':' // ; exec "$(command -v nodejs || command -v node)" "$0" "$@"
;

'use strict';

/* eslint-disable global-require */

const GROWN_TXT = `
  \u001b[32m▄████  ██▀███   ▒█████   █     █░███▄    █\u001b[39m
 \u001b[32m██▒ ▀█▒▓██ ▒ ██▒▒██▒  ██▒▓█░ █ ░█░██ ▀█   █\u001b[39m
\u001b[32m▒██░▄▄▄░▓██ ░▄█ ▒▒██░  ██▒▒█░ █ ░█▓██  ▀█ ██▒\u001b[39m
\u001b[32m░▓█  ██▓▒██▀▀█▄  ▒██   ██░░█░ █ ░█▓██▒  ▐▌██▒\u001b[39m
\u001b[32m░▒▓███▀▒░██▓ ▒██▒░ ████▓▒░░░██▒██▓▒██░   ▓██░\u001b[39m
 \u001b[32m░▒   ▒ ░ ▒▓ ░▒▓░░ ▒░▒░▒░ ░ ▓░▒ ▒ ░ ▒░   ▒ ▒\u001b[39m
  \u001b[32m░   ░   ░▒ ░ ▒░  ░ ▒ ▒░   ▒ ░ ░ ░ ░░   ░ ▒░\u001b[39m
  \u001b[32m░   ░   ░░   ░ ░ ░ ░ ▒    ░   ░    ░   ░ ░\u001b[39m
      \u001b[32m░    ░         ░ ░      ░            ░\u001b[39m
`;

const $ = require('wargs')(process.argv.slice(2), {
  booleans: 'IGRCARUSrvdfqhl',
  defaults: {
    cwd: process.cwd(),
    port: process.env.PORT || 8080,
    host: process.env.HOST || '0.0.0.0',
  },
  aliases: {
    I: 'no-install',
    G: 'no-clone',
    R: 'no-exec',
    C: 'no-copy',
    A: 'no-add',
    r: 'repl',
    U: 'uws',
    S: 'https',
    v: 'version',
    d: 'debug',
    f: 'force',
    q: 'quiet',
    x: 'exec',
    P: 'port',
    H: 'host',
    h: 'help',
    l: 'list',
    c: 'cwd',
    e: 'env',
  },
});

// defaults
process.name = 'grown';

process.env.NODE_ENV = $.flags.env || 'development';

/* istanbul ignore else */
if (process.env.CI) {
  process.env.NODE_ENV = 'ci';
}

delete $.flags.env;

const thisPkg = require('../package.json');
const exec = require('child_process').exec;
const cleanStack = require('clean-stack');
const chalk = require('chalk');
const path = require('path');
const fs = require('fs');

let _task = $._.shift();

const _ = require('./lib/util');

const _bin = path.basename(thisPkg.bin);

function showHelp() {
  _.echo(`${GROWN_TXT}
  Usage:
    ${_bin} new APP_PATH [...]

  Presets:
    ES6=buble|babel|traceur
    STYLES=less|sass|styl|postcss
    BUNDLER=fusebox|webpack|rollup
    RELOADER=browser-sync|live-reload
    DATABASE=postgres|mysql|mssql|sqlite

  Initialization options:
    -I, [--no-install]   # Skip installing dependencies
    -G, [--no-clone]     # Skip cloning repositories
    -R, [--no-exec]      # Skip running commands
    -C, [--no-copy]      # Skip copying sources
    -A, [--no-add]       # Skip writing files

  Runtime options:
    -f, [--force]        # Overwrite files that already exist
    -d, [--debug]        # Enable all debug messages
    -q, [--quiet]        # Suppress status output
    -c, [--cwd]          # Set the process.cwd()
    -P, [--port]         # Set PORT value (default: 80)
    -H, [--host]         # Set HOST value (default: 0.0.0.0)
    -e, [--env]          # Set NODE_ENV value (default: development)

  Server options:
    -R, [--repl]         # Enable the REPL
    -U, [--uws]          # Force UWS
    -S, [--https]        # Force HTTP

  Other actions:
    ${_bin} g|add|generate [...]
    ${_bin} s|up|start [...]
    ${_bin} c|repl

  Grown options:
    -l, [--list]         # List available generators
    -h, [--help]         # Show this help message and quit
    -x, [--exec]         # Execute a command before running
    -v, [--version]      # Show Grown version number and quit\n`);
}

/* istanbul ignore else */
if ($.flags.version) {
  _.echo(chalk.green(`${thisPkg.name} v${thisPkg.version}`), '\r\n');
  _.die();
}

/* istanbul ignore else */
if (!_task && $.flags.list) {
  _task = 'generate';
}

/* istanbul ignore else */
if ((!_task || $.flags.help) && !$.flags.exec) {
  showHelp();
  _.die();
}

const aliases = {
  generate: ['g', 'add'],
  start: ['s', 'up'],
  repl: ['c'],
};

Object.keys(aliases).forEach(key => {
  /* istanbul ignore else */
  if (aliases[key].indexOf(_task) > -1) {
    _task = key;
  }
});

function start(cb) {
  if ($.flags.exec) {
    const child = exec($.flags.exec);

    child.stdout.pipe(process.stdout);
    child.stderr.pipe(process.stderr);

    child.on(process.version.split('.')[1] === '6' ? 'exit' : 'close', exitCode => {
      if (exitCode !== 0) {
        _.die(1);
      } else {
        cb();
      }
    });
  } else {
    cb();
  }
}

function run() {
  try {
    _.echo(chalk.gray(`Grown v${thisPkg.version} (NODE_ENV=${process.env.NODE_ENV})`), '\r\n');

    const _tasks = {
      generate: require('./tasks/generate'),
      start: require('./tasks/start'),
      repl: require('./tasks/repl'),
      new: require('./tasks/new'),
    };

    const cwd = $.flags.cwd || process.cwd();

    delete $.flags.cwd;

    switch (_task) {
      case 'generate':
      case 'start':
      case 'repl':
      case 'new':
        _tasks[_task]($, cwd);
        break;

      default: {
        const _script = path.join(cwd, `app/scripts/${_task}.js`);

        /* istanbul ignore else */
        if (!fs.existsSync(_script)) {
          throw new Error(`Not implemented: ${_task}`);
        }

        const _farm = require(path.join(cwd, $._[0] || 'app/server'));

        _farm().emit('start')
          .then(ctx => require(_script)(ctx, $, {
            ok: msg => _.echo('\r', chalk.green(msg), '\n'),
            log: msg => _.echo('\r', chalk.gray(msg), '\n'),
            fail: msg => _.echo('\r', chalk.red(msg), '\n'),
            write: msg => _.echo(msg),
          }));
      }
    }
  } catch (e) {
    _.echo(chalk.red(($.flags.debug && cleanStack(e.stack)) || e.message), '\r\n');
    _.die(1);
  }
}

start(_task ? run : _.die);
