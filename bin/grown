#!/bin/sh

':' // ; exec "$(command -v nodejs || command -v node)" "$0" "$@"
;

'use strict';

/* eslint-disable global-require */
/* eslint-disable no-nested-ternary */

const GROWN_TXT = `
   \u001b[32m▄████  ██▀███   ▒█████   █     █░███▄    █\u001b[39m
  \u001b[32m██▒ ▀█▒▓██ ▒ ██▒▒██▒  ██▒▓█░ █ ░█░██ ▀█   █\u001b[39m
 \u001b[32m▒██░▄▄▄░▓██ ░▄█ ▒▒██░  ██▒▒█░ █ ░█▓██  ▀█ ██▒\u001b[39m
 \u001b[32m░▓█  ██▓▒██▀▀█▄  ▒██   ██░░█░ █ ░█▓██▒  ▐▌██▒\u001b[39m
 \u001b[32m░▒▓███▀▒░██▓ ▒██▒░ ████▓▒░░░██▒██▓▒██░   ▓██░\u001b[39m
  \u001b[32m░▒   ▒ ░ ▒▓ ░▒▓░░ ▒░▒░▒░ ░ ▓░▒ ▒ ░ ▒░   ▒ ▒\u001b[39m
   \u001b[32m░   ░   ░▒ ░ ▒░  ░ ▒ ▒░   ▒ ░ ░ ░ ░░   ░ ▒░\u001b[39m
   \u001b[32m░   ░   ░░   ░ ░ ░ ░ ▒    ░   ░    ░   ░ ░\u001b[39m
       \u001b[32m░    ░         ░ ░      ░            ░\u001b[39m
`;

const util = require('../lib/util');

let $;

try {
  $ = require('wargs')(process.argv.slice(2), {
    booleans: 'BTODIGRCAusVvdfqhly',
    camelCase: true,
    defaults: {
      cwd: process.cwd(),
      port: process.env.PORT || '8080',
      host: process.env.HOST || '0.0.0.0',
    },
    aliases: {
      y: 'interactive',
      B: 'no-bower',
      T: 'no-talavera',
      O: 'no-install-opts',
      D: 'no-install-dev',
      I: 'no-install',
      G: 'no-clone',
      R: 'no-exec',
      C: 'no-copy',
      A: 'no-add',
      i: 'repl',
      u: 'uws',
      s: 'https',
      v: 'version',
      V: 'verbose',
      d: 'debug',
      f: 'force',
      q: 'quiet',
      x: 'exec',
      P: 'port',
      H: 'host',
      h: 'help',
      l: 'list',
      c: 'cwd',
      e: 'env',
      a: 'app',
    },
  });
} catch (e) {
  util.printError(e);
  util.die(1);
}

// defaults
process.name = 'grown';

process.env.NODE_ENV = $.flags.env || 'development';

/* istanbul ignore else */
if (process.env.CI) {
  process.env.NODE_ENV = 'ci';
}

delete $.flags.env;

const thisPkg = require('../package.json');
const exec = require('child_process').exec;
const path = require('path');
const fs = require('fs-extra');

let _task = $._.shift();

/* istanbul ignore else */
if (!_task && $.flags.list) {
  _task = 'add';
}

// nice logs!
const _level = $.flags.verbose ? 'verbose' : $.flags.debug ? 'debug' : 'info';

const logger = require('log-pose')
  .setLevel(($.flags.quiet && !$.flags.version && !$.flags.help) ? false : _level)
  .getLogger(12, process.stdout, process.stderr);

if ($.flags.debug && $.flags.verbose) {
  require('debug').enable('json-schema-sequelizer,json-schema-sequelizer:*,grown,grown:*');
  require('log-pose').setLevel(false);
}

const cwd = $.flags.cwd || process.cwd();

delete $.flags.cwd;

function showHelp(taskName) {
  logger.write(GROWN_TXT);

  switch (taskName) {
    case 'init':
      logger.write(`
  Usage:
    grown init APP_NAME [TEMPLATE] [...]

  Examples:
    grown init .
    grown init site rad
    grown init my-app -y
    grown init example -fIT ES6=buble TESTS=mocha

  The default preset is an advanced application with just the application kernel,
  templates and some front-end assets. You can add support for models, bundling, testing, etc.

  However you can override the default layout by setting a different TEMPLATE:
    advanced   Full layout -deps
    starter    No layout -deps
    basic      No layout +deps (mocha babel webpack postcss browser-sync)
    rad        No layout +deps (jasmine-node buble rollup less live-reload)

  Presets:
    DATABASE   postgres | mysql | mssql | sqlite
    TESTS      ava | mocha | jasmine-node
    ES6        buble | babel | traceur
    BUNDLER    fusebox | webpack | rollup
    STYLES     less | sass | styl | postcss
    RELOADER   browser-sync | live-reload

  Options:
    -B, [--no-bower]           Skip installing tarima-bower support
    -T, [--no-talavera]        Skip images and talavera support
    -O, [--no-install-opts]    Skip installing dependencies
    -D, [--no-install-dev]     Skip installing dependencies
    -I, [--no-install]         Skip installing dependencies
    -G, [--no-clone]           Skip cloning repositories
    -R, [--no-exec]            Skip running commands
    -C, [--no-copy]            Skip copying sources
    -A, [--no-add]             Skip writing files
    -f, [--force]              Force without asking
    -V, [--verbose]            Installation logs
    -y, [--interactive]        Interactive mode

`);
      break;

    case 'add':
      logger.write(`
  TODO

`);
      break;

    case 'up':
      logger.write(`
  This will start your application under a supervised mode which
  is fine for most scenarios, edit and run your bin/server script
  for custom bootstraping.

  Options:
    -i, [--repl]        Enable the REPL
    -u, [--uws]         Force UWS
    -s, [--https]       Force HTTP

`);
      break;

    case 'db':
      logger.write(`
  TODO

`);
      break;

    case undefined:
      logger.write(`
  Usage:
    grown COMMAND [ARGS]

  Examples:
    grown up
    grown init -y
    grown repl -dV
    grown db --help
    grown db.migrate --use mydb --up
    grown add model.tpl User lib/controllers
    grown add model User title:string lib/models

  Any other call will fallback as ./lib/tasks/COMMAND or ./tasks/scripts/COMMAND script.

  Commands:
    init      Create a new application boilerplate
    add       Create application files
    db        Inspect and manage databases
    up        Start the application server
    repl      Start the console

  Grown options:
    -l, [--list]        List available generators
    -h, [--help]        Show any additional usage info
    -x, [--exec]        Execute a command before running
    -v, [--version]     Show Grown version number and quit

  Runtime options:
    -d, [--debug]       Enable all debug messages
    -q, [--quiet]       Suppress status output
    -c, [--cwd]         Set the process.cwd()
    -P, [--port]        Set PORT value (default: 8080)
    -H, [--host]        Set HOST value (default: 0.0.0.0)
    -e, [--env]         Set NODE_ENV value (default: development)
    -a, [--app]         Set the bootstrap script (default: lib/APP_NAME/application.js)

`);
      break;

    default:
      throw new Error(`Unknown ${taskName} task`);
  }
}

function start(cb) {
  process.on('exit', statusCode => {
    if (!statusCode) {
      logger.printf('\r\r{% end Done %}\n');
    }
  });

  if ($.flags.exec) {
    const child = exec($.flags.exec);

    child.stdout.pipe(process.stdout);
    child.stderr.pipe(process.stderr);

    child.on(process.version.split('.')[1] === '6' ? 'exit' : 'close', exitCode => {
      if (exitCode !== 0) {
        util.die(1);
      } else {
        cb();
      }
    });
  } else {
    cb();
  }
}

function run() {
  try {
    logger.info('\r{% green Grown v%s %} {% gray (node %s - %s) %}\r\n',
      thisPkg.version, process.version, process.env.NODE_ENV);

    const mainPkg = path.join(cwd, 'package.json');
    const appPkg = fs.existsSync(mainPkg)
      ? fs.readJsonSync(mainPkg)
      : {};

    let mainFile;

    if (_task !== 'init' && !$.flags.app) {
      const baseName = appPkg.name || path.basename(path.dirname(cwd));

      const files = [
        `lib/${baseName}/application.js`,
        `lib/${baseName}/server.js`,
        `lib/${baseName}/index.js`,
        `lib/${baseName}.js`,
        'lib/application.js',
        'lib/server.js',
        `${baseName}.js`,
        'application.js',
        'server.js',
        'index.js',
      ];

      if (files.indexOf(appPkg.main) === -1) {
        files.push(appPkg.main);
      }

      for (let i = 0; i < files.length; i += 1) {
        if (fs.existsSync(files[i])) {
          mainFile = path.resolve(cwd, files[i]);
          break;
        }
      }

      if (!mainFile) {
        throw new Error(`Missing application script (e.g: ${files.join(', ')})`);
      }

      if (!fs.existsSync(mainFile)) {
        throw new Error(`Missing ${path.relative(cwd, mainFile)} (add --help for usage info)`);
      }

      $.flags.app = mainFile;
    }

    const _tasks = {
      init: require('./tasks/new'),
      add: require('./tasks/generate'),
      up: require('./tasks/start'),
      repl: require('./tasks/repl'),
    };

    switch (_task) {
      case 'init':
      case 'add':
      case 'up':
      case 'repl':
        _tasks[_task]($, cwd, logger);
        break;

      default: {
        const _file = path.join(cwd, `lib/tasks/${_task}`);

        logger.info('\r{% wait Task %s: loading... %}\r\r', _task);

        // try user first, then built-in
        const _call = require(!fs.existsSync(_file)
          ? `./tasks/scripts/${_task}`
          : _file);

        /* istanbul ignore else */
        if (typeof _call !== 'function') {
          throw new Error(`Task must be a function, given: ${_call}`);
        }

        const _farm = require(mainFile);

        logger.info('\r{% wait Task %s: running... %}\r\r', _task);

        _farm()
          .run(ctx => _call(ctx, $, logger))
          .then(() => _farm.teardown())
          .catch(e => _farm.teardown(() => {
            util.printError(e, $.flags, logger);
            util.die(1);
          }));
      }
    }
  } catch (e) {
    util.printError(e, $.flags, logger);
    util.die(1);
  }
}

/* istanbul ignore else */
if ($.flags.version) {
  logger.printf('\r{% green %s v%s %} {% gray (node %s) %}\r\n',
    thisPkg.name, thisPkg.version,
    process.version);
  util.die();
}

process.on('unhandledRejection', e => {
  util.printError(e, $.flags, logger);
  util.die(1);
});

process.on('uncaughtException', e => {
  util.printError(e, $.flags, logger);
  util.die(1);
});

if ((!_task || $.flags.help || (!_task && $.flags.help)) && !$.params.exec) {
  showHelp(_task);
  util.die();
} else {
  start(_task ? run : util.die);
}
