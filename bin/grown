#!/bin/sh

':' // ; exec "$(command -v nodejs || command -v node)" "$0" "$@"
;

'use strict';

/* eslint-disable global-require */

const GROWN_TXT = `
  \u001b[32m▄████  ██▀███   ▒█████   █     █░███▄    █\u001b[39m
 \u001b[32m██▒ ▀█▒▓██ ▒ ██▒▒██▒  ██▒▓█░ █ ░█░██ ▀█   █\u001b[39m
\u001b[32m▒██░▄▄▄░▓██ ░▄█ ▒▒██░  ██▒▒█░ █ ░█▓██  ▀█ ██▒\u001b[39m
\u001b[32m░▓█  ██▓▒██▀▀█▄  ▒██   ██░░█░ █ ░█▓██▒  ▐▌██▒\u001b[39m
\u001b[32m░▒▓███▀▒░██▓ ▒██▒░ ████▓▒░░░██▒██▓▒██░   ▓██░\u001b[39m
 \u001b[32m░▒   ▒ ░ ▒▓ ░▒▓░░ ▒░▒░▒░ ░ ▓░▒ ▒ ░ ▒░   ▒ ▒\u001b[39m
  \u001b[32m░   ░   ░▒ ░ ▒░  ░ ▒ ▒░   ▒ ░ ░ ░ ░░   ░ ▒░\u001b[39m
  \u001b[32m░   ░   ░░   ░ ░ ░ ░ ▒    ░   ░    ░   ░ ░\u001b[39m
      \u001b[32m░    ░         ░ ░      ░            ░\u001b[39m
`;

const $ = require('wargs')(process.argv.slice(2), {
  aliases: {
    I: 'no-install',
    v: 'version',
    d: 'debug',
    f: 'force',
    q: 'quiet',
    x: 'exec',
    P: 'port',
    H: 'host',
    h: 'help',
    l: 'list',
    p: 'cwd',
    e: 'env',
  },
});

/* istanbul ignore else */
if (typeof $.flags.env === 'string') {
  process.env.NODE_ENV = $.flags.env;
}

/* istanbul ignore else */
if (process.env.CI) {
  process.env.NODE_ENV = 'ci';
}

process.env.NODE_ENV = process.env.NODE_ENV || 'development';

const thisPkg = require('../package.json');
const exec = require('child_process').exec;
const cleanStack = require('clean-stack');
const chalk = require('chalk');
const path = require('path');
const fs = require('fs');

let _task = $._.shift();

const _ = require('./lib/util');

const _bin = path.basename(thisPkg.bin);

function showHelp() {
  _.echo(`${GROWN_TXT}
  Usage:
    ${_bin} new APP_PATH [...]

  Initialization options:
    -I, [--no-install]   # Skip installation of any dependencies

  Runtime options:
    -f, [--force]        # Overwrite files that already exist
    -q, [--quiet]        # Suppress status output
    -e, [--env]          # Set NODE_ENV value

  Other actions:
    ${_bin} g|add|generate [...]
    ${_bin} s|up|start [...]
    ${_bin} c|repl

  Grown options:
    -h, [--help]         # Show this help message and quit
    -v, [--version]      # Show Grown version number and quit\n`);
}

/* istanbul ignore else */
if ($.flags.version) {
  _.echo(chalk.green(`${thisPkg.name} v${thisPkg.version}`), '\n');
  _.die();
}

/* istanbul ignore else */
if (!_task || $.flags.help) {
  showHelp();
  _.die();
}

const aliases = {
  generate: ['g', 'add'],
  start: ['s', 'up'],
  repl: ['c'],
};

Object.keys(aliases).forEach(key => {
  /* istanbul ignore else */
  if (aliases[key].indexOf(_task) > -1) {
    _task = key;
  }
});

function run() {
  try {
    _.echo(chalk.gray(`Grown v${thisPkg.version} (NODE_ENV=${process.env.NODE_ENV})`), '\n');

    const _tasks = {
      generate: require('./tasks/generate'),
      start: require('./tasks/start'),
      repl: require('./tasks/repl'),
      new: require('./tasks/new'),
    };

    switch (_task) {
      case 'generate':
      case 'start':
      case 'repl':
      case 'new':
        _tasks[_task]($);
        break;

      default: {
        const cwd = process.cwd();

        const _script = path.join(cwd, `app/scripts/${_task}.js`);

        /* istanbul ignore else */
        if (!fs.existsSync(_script)) {
          throw new Error(`Not implemented: ${_task}`);
        }

        const _farm = require(path.join(cwd, $._[0] || 'app/server'));

        _farm.teardown(() => _farm().emit('start')
          .then(ctx => require(_script)(ctx, $, _.logger)));
      }
    }
  } catch (e) {
    _.echo(chalk.red(($.flags.debug && cleanStack(e.stack)) || e.message), '\n');
    _.die(1);
  }
}

if ($.flags.exec) {
  const child = exec($.flags.exec);

  child.stdout.pipe(process.stdout);
  child.stderr.pipe(process.stderr);

  child.on(process.version.split('.')[1] === '6' ? 'exit' : 'close', exitCode => {
    if (exitCode !== 0) {
      _.die(1);
    } else {
      run();
    }
  });
} else {
  run();
}
